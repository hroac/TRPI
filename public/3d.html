<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Infinite Tunnel with Box Collision & Aligned Cubes</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>
let tunnelRadius = 150;
let tunnelLength = 10000;
let numTunnelSegments = 2;
let forwardSpeed = 20;
let lateralSpeed = 10;
let cornersPerRing = 16;
let ringSpacing = 300;
let ringCount = 20;
let ringGroupLength = ringSpacing * (ringCount - 1);
let ringGroupCopies = 10;
let tronColors = [0x00ffff, 0xff00ff, 0xffff00, 0x00ff00, 0xff6600];
let tunnelSegments = [], ringGroups = [], cubes = [];
let scene, camera, renderer, tunnelContainer, cubeGroup;
function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0x000000);
  tunnelContainer = new THREE.Group();
  scene.add(tunnelContainer);
  cubeGroup = new THREE.Group();
  tunnelContainer.add(cubeGroup);
  camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 20000);
  camera.position.set(0, -100, -100);
  camera.lookAt(new THREE.Vector3(0, -100, 1));
  scene.add(camera);
  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);
  createTunnelSegments();
  createRingGroups();
  window.addEventListener("keydown", onKeyDown);
  window.addEventListener("resize", onResize);
  requestGyroPermission();
  setInterval(generateCubesBatch,1000);
}
function createTunnelSegments(){
  for(let i=0;i<numTunnelSegments;i++){
    let segGroup = new THREE.Group();
    let geom = new THREE.CylinderGeometry(tunnelRadius, tunnelRadius, tunnelLength, 16, 16, true);
    geom.rotateX(Math.PI/2);
    let paneMesh = new THREE.Mesh(geom, new THREE.MeshBasicMaterial({color:0xffffff, side:THREE.BackSide}));
    let edges = new THREE.EdgesGeometry(geom);
    let wireframe = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({color:0x000000, linewidth:10}));
    wireframe.scale.set(1.1,1.1,1.1);
    segGroup.add(paneMesh);
    segGroup.add(wireframe);
    segGroup.position.z = i * tunnelLength;
    tunnelSegments.push(segGroup);
    tunnelContainer.add(segGroup);
  }
}
function createRingGroups(){
  for(let i=0;i<ringGroupCopies;i++){
    let group = createRingsGroup();
    group.position.z = i * ringGroupLength;
    ringGroups.push(group);
    tunnelContainer.add(group);
  }
}
function createRingsGroup(){
  let group = new THREE.Group();
  for(let i=0;i<ringCount;i++){
    let ringZ = i * ringSpacing, ringPoints = [];
    for(let c=0;c<cornersPerRing;c++){
      let theta = (c/cornersPerRing)*2*Math.PI;
      let x = tunnelRadius*Math.cos(theta), y = tunnelRadius*Math.sin(theta);
      ringPoints.push(new THREE.Vector3(x,y,ringZ));
    }
    for(let c=0;c<cornersPerRing;c++){
      let nextC = (c+1)%cornersPerRing;
      let geom = new THREE.BufferGeometry().setFromPoints([ringPoints[c], ringPoints[nextC]]);
      let line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0x000000, linewidth:10}));
      group.add(line);
    }
    if(i < ringCount-1){
      let nextPoints = [];
      let nextZ = (i+1)*ringSpacing;
      for(let c=0;c<cornersPerRing;c++){
        let theta = (c/cornersPerRing)*2*Math.PI;
        let x = tunnelRadius*Math.cos(theta), y = tunnelRadius*Math.sin(theta);
        nextPoints.push(new THREE.Vector3(x,y,nextZ));
      }
      for(let c=0;c<cornersPerRing;c++){
        let geom = new THREE.BufferGeometry().setFromPoints([ringPoints[c], nextPoints[c]]);
        let line = new THREE.Line(geom, new THREE.LineBasicMaterial({color:0x000000, linewidth:10}));
        group.add(line);
      }
    }
  }
  return group;
}
function moveSegments(arr, segLength, totalCount){
  for(let seg of arr) seg.position.z -= forwardSpeed;
  if(arr[0].position.z < camera.position.z - segLength){
    let seg = arr.shift();
    seg.position.z += totalCount * segLength;
    arr.push(seg);
  }
}
function generateCubeOnVertex(){
  if(collisionDetected()) return;
  let rg = ringGroups[Math.floor(Math.random()*ringGroups.length)];
  let vertexIdx = Math.floor(Math.random()*cornersPerRing);
  let angle = (vertexIdx/cornersPerRing)*2*Math.PI;
  // Always generate at z = camera.position.z + 5000
  let z = camera.position.z + 5000;
  let type = Math.random() < 0.5 ? "across" : "cube";
  let tronColor = tronColors[Math.floor(Math.random()*tronColors.length)];
  let mesh, offset;
  if(type==="across"){
    let width = 200, height = 50, depth = 50;
    let geo = new THREE.BoxGeometry(width, height, depth);
    geo.translate(depth/2, 0, 0);
    let mat = new THREE.MeshBasicMaterial({color: tronColor});
    mesh = new THREE.Mesh(geo, mat);
    offset = depth/2;
  } else {
    let size = 100;
    let geo = new THREE.BoxGeometry(size, size, size);
    geo.translate(size/2, 0, 0);
    let mat = new THREE.MeshBasicMaterial({color: tronColor});
    mesh = new THREE.Mesh(geo, mat);
    offset = size/2;
  }
  let wire = new THREE.LineSegments(new THREE.WireframeGeometry(mesh.geometry), new THREE.LineBasicMaterial({color:0x000000, linewidth:3}));
  mesh.add(wire);
  let r = tunnelRadius + offset;
  let x = r * Math.cos(angle);
  let y = r * Math.sin(angle);
  mesh.position.set(x, y, z);
  // Align the object's front face (local +X) flush with the wall.
  mesh.quaternion.setFromUnitVectors(new THREE.Vector3(1,0,0), new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0));
  cubeGroup.add(mesh);
  cubes.push(mesh);
}
function generateCubesBatch(){
  for(let i=0;i<3;i++){
    generateCubeOnVertex();
  }
}
function updateCubes(){
  for(let i=cubes.length-1;i>=0;i--){
    cubes[i].position.z -= forwardSpeed;
    if(cubes[i].position.z < camera.position.z - 200){
      cubeGroup.remove(cubes[i]);
      cubes.splice(i,1);
    }
  }
}
function collisionDetected(){
  // For each cube, compute its world bounding box and check if it contains the camera position.
  let camPos = camera.position.clone();
  for(let cube of cubes){
    let box = new THREE.Box3().setFromObject(cube);
    if(box.containsPoint(camPos)){
      return true;
    }
  }
  return false;
}
function handleOrientation(event){
  console.log(event.gamma, event.beta, event.alpha);
  let gamma = event.gamma || 0;
  tunnelContainer.rotation.z = THREE.MathUtils.degToRad(gamma);
}
function requestGyroPermission(){
  if(typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
    DeviceOrientationEvent.requestPermission().then(permissionState=>{
      if(permissionState==='granted'){
        window.addEventListener("deviceorientation", handleOrientation, true);
      }
    }).catch(console.error).then(() =>{ 
    window.addEventListener("deviceorientation", handleOrientation, true);
    });
  } else {
    window.addEventListener("deviceorientation", handleOrientation, true);
  }
}
function onKeyDown(e){
  if(e.key.toLowerCase()==="a"){
    tunnelContainer.rotation.z += 0.05;
  } else if(e.key.toLowerCase()==="d"){
    tunnelContainer.rotation.z -= 0.05;
  } else if(e.key==="ArrowLeft"){
    camera.position.x -= lateralSpeed;
  } else if(e.key==="ArrowRight"){
    camera.position.x += lateralSpeed;
  }
}
function onResize(){
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
}
function initScene(){
  init();
  requestGyroPermission();
  setInterval(generateCubesBatch,5000);
}
function animate(){
  requestAnimationFrame(animate);
  if(!collisionDetected()){
    moveSegments(tunnelSegments, tunnelLength, numTunnelSegments);
    moveSegments(ringGroups, ringGroupLength, ringGroupCopies);
    updateCubes();
  } else {
    forwardSpeed = 0;
    console.log("Collision detected! Stopping movement.");
  }
  renderer.render(scene, camera);
}
initScene();
animate();
</script>
</body>
</html>
