import { randomBytes } from 'crypto';
export { }

declare global {
    interface Date {
        addMonths(months: number): Date;
        addDays(days: number): Date;
        addHours(hours: number): Date;
    }

    interface String {
        capitalize(): string;
    }
    interface Guid {
        create(input?: string): Guid
        toString(): string
        empty(): string
        parse(input: string): Guid

    }
}

String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.slice(1);
}

    Date.prototype.addMonths = function (months) {
        this.setMonth(this.getMonth() + months);
        return this;
}

    Date.prototype.addDays = function (days) {
        this.setDate(this.getDate() + days);
        return this;
}

Date.prototype.addHours = function (hours) {
    this.setHours(this.getHours() + hours);
    return this;
}

class Guid {
    public constructor(input?: string) {
        let byteArray : Uint8Array = new Uint8Array();
        if (input) {
            if (!Guid.parse(input)) {
                this.value = Guid.empty();
            }
            byteArray = Guid.decodeGuid(input);
        }
        this.byteArray = byteArray||randomBytes(16);
        this.value = Guid.encodeGuid(this.byteArray);
    }

    private byteArray: Uint8Array;
    public value: string;

    public static parse(input: string): boolean {

        // Regular expression to match the GUID format generated by the `guid` function
        const guidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;

        // Test the input against the regular expression
        return guidPattern.test(input);
    }

    public static empty(): string {
        return "00000000-0000-0000-0000-000000000000";
    }


    //tostring
    private static encodeGuid(byteArray: any): string {
        if (!(byteArray instanceof Uint8Array) || byteArray.length !== 16) {
            throw new Error('Invalid input: expected a Uint8Array of length 16');
        }

        const hexArray = [];
        for (let i = 0; i < byteArray.length; i++) {
            const hex = byteArray[i].toString(16).padStart(2, '0');
            hexArray.push(hex);
       }
       const guid = `${hexArray.slice(0, 4).join('')}-${hexArray.slice(4, 6).join('')}-${hexArray.slice(6, 8).join('')}-${hexArray.slice(8, 10).join('')}-${hexArray.slice(10, 16).join('')}`;

        return guid;
    }

    //guidtobytearray
    private static decodeGuid(guid: string) : Uint8Array {
        const cleanGuid = guid.replace(/-/g, '');

    
        if (cleanGuid.length !== 32) {
            throw new Error('Invalid GUID format');
        }
        
        const byteArray = new Uint8Array(16);

        // Convert each pair of hex digits into a byte
        for (let i = 0; i < 16; i++) {
            byteArray[i] = parseInt(cleanGuid.substr(i * 2, 2), 16);
        }

        return byteArray;
    }

}




