<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
<title>Infinite Tunnel (Rotating, Camera at Bottom, No Comments)</title>

    <style>
html, body { margin: 0; padding: 0; overflow: hidden; background: #000; }

      canvas { display: block; }
    </style>
  </head>
<body></body>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
      const tunnelRadius = 150;
const tunnelLength = 10000; const numTunnelSegments = 2; const forwardSpeed =
20; const lateralSpeed = 10;

      const cornersPerRing = 16;
      const ringSpacing = 300;
      const ringCount = 20;
      const ringGroupLength = ringSpacing * (ringCount - 1);
      const ringGroupCopies = 10;
let tunnelSegments = []; let ringGroups = [];


      let scene, camera, renderer;
let tunnelContainer;

      function init() {
        scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);

        tunnelContainer = new THREE.Group();
        scene.add(tunnelContainer);
const cameraHeight = -tunnelRadius; camera = new THREE.PerspectiveCamera(75,
window.innerWidth/window.innerHeight, 0.1, 20000);


camera.position.set(0, -100, -100);


        camera.lookAt(new THREE.Vector3(0, -100, 1));
scene.add(camera);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

createTunnelSegments();

createRingGroups();

        window.addEventListener("keydown", onKeyDown);
        window.addEventListener("resize", onResize);
requestGyroPermission(); }


      function createTunnelSegments() {
        for (let i = 0; i < numTunnelSegments; i++) {
const segGroup = new THREE.Group();

          const geom = new THREE.CylinderGeometry(tunnelRadius, tunnelRadius, tunnelLength, 16, 16, true);
geom.rotateX(Math.PI / 2);

          const paneMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.BackSide });
const paneMesh = new THREE.Mesh(geom, paneMat);

          const edges = new THREE.EdgesGeometry(geom);
const wireMat = new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 10 });

          const wireframe = new THREE.LineSegments(edges, wireMat);
wireframe.scale.set(1.1, 1.1, 1.1);

          segGroup.add(paneMesh);
segGroup.add(wireframe);

          segGroup.position.z = i * tunnelLength;
          tunnelSegments.push(segGroup);
          tunnelContainer.add(segGroup);
        }
}

      function createRingGroups() {
        for (let i = 0; i < ringGroupCopies; i++) {
          const group = createRingsGroup();
          group.position.z = i * ringGroupLength;
          ringGroups.push(group);
          tunnelContainer.add(group);
        }
}

      function createRingsGroup() {
        const group = new THREE.Group();
        for (let i = 0; i < ringCount; i++) {
          const ringZ = i * ringSpacing;
          let ringPoints = [];
          for (let c = 0; c < cornersPerRing; c++) {
            const theta = (c / cornersPerRing) * 2 * Math.PI;
            const x = tunnelRadius * Math.cos(theta);
            const y = tunnelRadius * Math.sin(theta);
            ringPoints.push(new THREE.Vector3(x, y, ringZ));
          }
          for (let c = 0; c < cornersPerRing; c++) {
            const nextC = (c + 1) % cornersPerRing;
            const geom = new THREE.BufferGeometry().setFromPoints([ringPoints[c], ringPoints[nextC]]);
const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0x000000,
linewidth: 10 }));

            group.add(line);
          }
          if (i < ringCount - 1) {
            let nextPoints = [];
            const nextZ = (i + 1) * ringSpacing;
            for (let c = 0; c < cornersPerRing; c++) {
              const theta = (c / cornersPerRing) * 2 * Math.PI;
              const x = tunnelRadius * Math.cos(theta);
              const y = tunnelRadius * Math.sin(theta);
              nextPoints.push(new THREE.Vector3(x, y, nextZ));
            }
            for (let c = 0; c < cornersPerRing; c++) {
              const geom = new THREE.BufferGeometry().setFromPoints([ringPoints[c], nextPoints[c]]);
const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: 0x000000,
linewidth: 10 }));

              group.add(line);
            }
          }
        }
        return group;
}

      function moveSegments(arr, segLength, totalCount) {
for (let seg of arr) { seg.position.z -= forwardSpeed; }

        if (arr[0].position.z < camera.position.z - segLength) {
          let seg = arr.shift();
          seg.position.z += totalCount * segLength;
          arr.push(seg);
        }
}

      function handleOrientation(event) {
console.log("Device orientation:", event.gamma, event.beta, event.alpha); let
gamma = event.gamma || 0;

        tunnelContainer.rotation.z = THREE.MathUtils.degToRad(gamma);
camera.position.x += THREE.MathUtils.degToRad(gamma) * 0.5;

      }
function requestGyroPermission() { if (typeof DeviceOrientationEvent !==
'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
DeviceOrientationEvent.requestPermission() .then(permissionState => { if
(permissionState === 'granted') { window.addEventListener("deviceorientation",
handleOrientation, true); console.log("Gyro permission granted."); } })
.catch(console.error); } else { window.addEventListener("deviceorientation",
handleOrientation, true); } }


      function onKeyDown(e) {
        if (e.key.toLowerCase() === "a") {
          tunnelContainer.rotation.z += 0.05;
        } else if (e.key.toLowerCase() === "d") {
          tunnelContainer.rotation.z -= 0.05;
        } else if (e.key === "ArrowLeft") {
          camera.position.x -= lateralSpeed;
        } else if (e.key === "ArrowRight") {
          camera.position.x += lateralSpeed;
        }
}

      function onResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
function initScene() { init(); requestGyroPermission(); }


      function animate() {
requestAnimationFrame(animate);

        moveSegments(tunnelSegments, tunnelLength, numTunnelSegments);
moveSegments(ringGroups, ringGroupLength, ringGroupCopies);

        renderer.render(scene, camera);
}

      initScene();
      animate();
    </script>
  </body>
</html>
